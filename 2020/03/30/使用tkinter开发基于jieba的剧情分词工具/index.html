<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>使用Tkinter开发基于Jieba的剧情分词工具 | 萧山码农</title>
    <meta name="description" content="

先上个成果图吧：

UI界面

实现的功能

共现矩阵的生成和导出——帮助生成关系图
频繁模式的识别和导出——帮助分析人物关系
词频的统计和导出
分词和导出
角色和别名识别（人工录入）

用Tk写GUI真的反人类
 ...">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/assets/css/0.styles.b9adda82.css" as="style"><link rel="preload" href="/assets/js/app.5d19b8fa.js" as="script"><link rel="preload" href="/assets/js/9.785256bf.js" as="script"><link rel="preload" href="/assets/js/7.5b24e917.js" as="script"><link rel="preload" href="/assets/js/15.fa42f190.js" as="script"><link rel="prefetch" href="/assets/js/1.468c81c5.js"><link rel="prefetch" href="/assets/js/10.6df78991.js"><link rel="prefetch" href="/assets/js/11.23a1f3de.js"><link rel="prefetch" href="/assets/js/12.81c370ce.js"><link rel="prefetch" href="/assets/js/13.2d1c06ef.js"><link rel="prefetch" href="/assets/js/14.42a69f97.js"><link rel="prefetch" href="/assets/js/16.a41cc8a3.js"><link rel="prefetch" href="/assets/js/17.19e6dac1.js"><link rel="prefetch" href="/assets/js/18.5fc62336.js"><link rel="prefetch" href="/assets/js/19.c275d46b.js"><link rel="prefetch" href="/assets/js/20.d67102d1.js"><link rel="prefetch" href="/assets/js/21.39229d98.js"><link rel="prefetch" href="/assets/js/22.09e8a15a.js"><link rel="prefetch" href="/assets/js/23.3f34f348.js"><link rel="prefetch" href="/assets/js/24.1489dc2a.js"><link rel="prefetch" href="/assets/js/25.857dc890.js"><link rel="prefetch" href="/assets/js/26.ab567800.js"><link rel="prefetch" href="/assets/js/27.5ab9a097.js"><link rel="prefetch" href="/assets/js/28.c8795ca2.js"><link rel="prefetch" href="/assets/js/29.65a21c73.js"><link rel="prefetch" href="/assets/js/5.cdfe8ec9.js"><link rel="prefetch" href="/assets/js/6.7ab562dc.js"><link rel="prefetch" href="/assets/js/8.45daed47.js"><link rel="prefetch" href="/assets/js/vendors~flowchart.908db966.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.bd4608b1.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b9adda82.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">萧山码农 </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">萧山码农 </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">Tags</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><div class="vuepress-blog-theme-content"><div class="content__default"><h1 id="使用tkinter开发基于jieba的剧情分词工具"><a href="#使用tkinter开发基于jieba的剧情分词工具" class="header-anchor">#</a> 使用Tkinter开发基于Jieba的剧情分词工具</h1> <p>先上个成果图吧：</p> <p><img src="https://github.com/KXXH/KR_plot_analysis/raw/master/img/tool_ui_1.png" alt="UI界面"></p> <h2 id="实现的功能"><a href="#实现的功能" class="header-anchor">#</a> 实现的功能</h2> <ul><li>共现矩阵的生成和导出——帮助生成关系图</li> <li>频繁模式的识别和导出——帮助分析人物关系</li> <li>词频的统计和导出</li> <li>分词和导出</li> <li>角色和别名识别（人工录入）</li></ul> <h2 id="用tk写gui真的反人类"><a href="#用tk写gui真的反人类" class="header-anchor">#</a> 用Tk写GUI真的反人类</h2> <p>Tk和一大波有着悠久历史的GUI框架，布局文件和业务逻辑代码不分。想来想去最好的办法是用类和继承来封装控件，不过一开始就只打算做个小工具，所以没有做类的封装。结果搞得十分头大，全局变量一堆，UI逻辑代码就奔着400行去了，唉，还是太年轻了😂。有机会再重构吧。</p> <p><img src="/assets/img/plot_tool_ui_1.07411061.png" alt="UI整体结构"></p> <p>在Tk中，只有三种布局方式，pack，place和grid。其中，pack只能选择飘到某一边，place只能根据绝对位置进行定位，二者都不如grid灵活。不过，通过pack和Frame组合，也能起到不错的效果。我们这里使用grid布局，使用Frame整合较小的部件，以方便布局。蓝色的Frame是文字编辑区域，使用<code>Notebook</code>组件实现标签切换。每个标签下有一个<code>Text</code>，显示文字内容。</p> <p>实际上这三个Tag之间是有联系的，当切换到分句或者分词时，应该<strong>根据填入的剧情去刷新分句和分词的内容</strong>。但是<code>Notebook</code>组件的唯一事件——<code>&lt;&lt;NotebookTabChanged&gt;&gt;</code>携带的参数似乎并不能真实反映选中激活的Tag。因此不得不使用比较Low的办法，手动在获得事件回调时，获取当前激活的Tag，进行比较：</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">tab_switch_callback</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">:</span>
    index <span class="token operator">=</span> main_ntb<span class="token punctuation">.</span>index<span class="token punctuation">(</span>main_ntb<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>
    <span class="token keyword">elif</span> index <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        text <span class="token operator">=</span> plot_text<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">&quot;1.0&quot;</span><span class="token punctuation">,</span> END<span class="token punctuation">)</span>
        mt<span class="token punctuation">.</span>set_text<span class="token punctuation">(</span>text<span class="token punctuation">)</span>
        refresh_splited_text<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">elif</span> index <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
        text <span class="token operator">=</span> plot_text<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">&quot;1.0&quot;</span><span class="token punctuation">,</span> END<span class="token punctuation">)</span>
        mt<span class="token punctuation">.</span>set_text<span class="token punctuation">(</span>text<span class="token punctuation">)</span>
        refresh_cut_text<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
main_ntb<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token string">&quot;&lt;&lt;NotebookTabChanged&gt;&gt;&quot;</span><span class="token punctuation">,</span> tab_switch_callback<span class="token punctuation">)</span>

</code></pre></div><p>当然每次点击就发送文本给分词器开销未免太大，特别是在文本较长的情况下。因此我使用了一些缓存，每次对分词器调用<code>set_text</code>方法时，会先比对发送来的文本与已有文本是否一致。如果一致则忽略，否则，积极修改分句结果（因为分句使用正则表达式，效率还是比较高的），惰性修改分词结果（清除分词结果缓存，下次调用分词方法时重新生成）。</p> <div class="vuepress-flowchart loading"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 30 30" class="vuepress-flowchart-loading-icon" style="enable-background:new 0 0 50 50;"><rect x="0" y="13" width="4" height="5"><animate attributeName="height" attributeType="XML" values="5;21;5" begin="0s" dur="0.6s" repeatCount="indefinite"></animate> <animate attributeName="y" attributeType="XML" values="13; 5; 13" begin="0s" dur="0.6s" repeatCount="indefinite"></animate></rect> <rect x="10" y="13" width="4" height="5"><animate attributeName="height" attributeType="XML" values="5;21;5" begin="0.15s" dur="0.6s" repeatCount="indefinite"></animate> <animate attributeName="y" attributeType="XML" values="13; 5; 13" begin="0.15s" dur="0.6s" repeatCount="indefinite"></animate></rect> <rect x="20" y="13" width="4" height="5"><animate attributeName="height" attributeType="XML" values="5;21;5" begin="0.3s" dur="0.6s" repeatCount="indefinite"></animate> <animate attributeName="y" attributeType="XML" values="13; 5; 13" begin="0.3s" dur="0.6s" repeatCount="indefinite"></animate></rect></svg></div><div class="language-python extra-class"><pre class="language-python"><code>    <span class="token keyword">def</span> <span class="token function">set_text</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">:</span>
        text <span class="token operator">=</span> text<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>text <span class="token operator">!=</span> text<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>text <span class="token operator">=</span> text
            self<span class="token punctuation">.</span>_split_text<span class="token punctuation">(</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>_cache_expired<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 缓存过期</span>
</code></pre></div><h2 id="关于分词词典和名称处理"><a href="#关于分词词典和名称处理" class="header-anchor">#</a> 关于分词词典和名称处理</h2> <p>分词词典是一定要做的，因为通常的剧情介绍中都含有大量的人名，而人名在分词中是有一定概率被切开的。同时，我们也要处理各种指向同一个人的别称。NLP中有“共指消解”也是类似于这一目的。但是目前在中文领域共指消解的效果并不是十分理想，因此我们还是选用了手动录入别称的办法。</p> <p>我们在分词器中使用了两个字典来保存这一组信息。其中一组称为“名称字典”，保存的Key是角色的<em>正式名称</em>（出现在共现矩阵等位置的名称），value是角色的别名的<em>集合</em>。该部分用于直观地管理一个角色拥有的多个别名。另一组称之为“倒排名称字典”，类似于搜索引擎中的倒排索引的究极简化版。这一部分保存的是别名→角色名的映射，用于替换角色的别名。当需要分词时，我们用两组字典的Key的集合的并集作为分词字典。</p> <div class="vuepress-flowchart loading"><svg xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" viewBox="0 0 30 30" class="vuepress-flowchart-loading-icon" style="enable-background:new 0 0 50 50;"><rect x="0" y="13" width="4" height="5"><animate attributeName="height" attributeType="XML" values="5;21;5" begin="0s" dur="0.6s" repeatCount="indefinite"></animate> <animate attributeName="y" attributeType="XML" values="13; 5; 13" begin="0s" dur="0.6s" repeatCount="indefinite"></animate></rect> <rect x="10" y="13" width="4" height="5"><animate attributeName="height" attributeType="XML" values="5;21;5" begin="0.15s" dur="0.6s" repeatCount="indefinite"></animate> <animate attributeName="y" attributeType="XML" values="13; 5; 13" begin="0.15s" dur="0.6s" repeatCount="indefinite"></animate></rect> <rect x="20" y="13" width="4" height="5"><animate attributeName="height" attributeType="XML" values="5;21;5" begin="0.3s" dur="0.6s" repeatCount="indefinite"></animate> <animate attributeName="y" attributeType="XML" values="13; 5; 13" begin="0.3s" dur="0.6s" repeatCount="indefinite"></animate></rect></svg></div><p>经过上述操作就可以得到每行出现的角色。</p> <div class="language-python extra-class"><pre class="language-python"><code>    <span class="token keyword">def</span> <span class="token function">names_by_sentence</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> drop_empty<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        cut_result <span class="token operator">=</span> self<span class="token punctuation">.</span>cut<span class="token punctuation">(</span><span class="token punctuation">)</span>
        words_dict <span class="token operator">=</span> self<span class="token punctuation">.</span>_generate_words_dict<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> line <span class="token keyword">in</span> cut_result<span class="token punctuation">:</span>
            <span class="token comment">#替换角色名</span>
            word_set <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>reversed_name_dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span>
                word<span class="token punctuation">)</span> <span class="token keyword">or</span> word <span class="token keyword">for</span> word <span class="token keyword">in</span> line<span class="token punctuation">)</span>
            <span class="token comment">#过滤停用词</span>
            word_set_without_stopwords <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token builtin">filter</span><span class="token punctuation">(</span>
                <span class="token keyword">lambda</span> word<span class="token punctuation">:</span> word <span class="token keyword">not</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>STOPWORDS<span class="token punctuation">,</span> word_set<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token comment">#取剩余结果和角色名字典的交集</span>
            name_set <span class="token operator">=</span> word_set_without_stopwords <span class="token operator">&amp;</span> words_dict
            <span class="token keyword">if</span> drop_empty <span class="token keyword">and</span> <span class="token keyword">not</span> name_set<span class="token punctuation">:</span>
                <span class="token keyword">continue</span>
            <span class="token keyword">yield</span> name_set
</code></pre></div><h2 id="关于共现矩阵"><a href="#关于共现矩阵" class="header-anchor">#</a> 关于共现矩阵</h2> <p>稍微找了一下，也没有看到方便的共现矩阵库，于是自己写了一个很<s>简陋</s>简单的实现。整体的复杂度还是挺高的，利用了<code>itertools.combinations</code>这一魔法迭代器，即：对于每行提取出的角色集合，生成他们的所有长度为2的组合。对于每一个组合，我们计算其出现了一次。由于共现矩阵应该是比较稀疏的，因此使用<code>defaultdict</code>，可以比较方便地抽象这一种情形（当然，<code>Counter</code>也可以。但是<code>Counter</code>只能对元组计数，如果只是统计角色对的出现次数是没有任何问题，而且能把代码写得更加简洁，不过我们想要的是矩阵，<code>Counter</code>的Key是元组，需要多一层转换。）</p> <div class="language-python extra-class"><pre class="language-python"><code>    <span class="token keyword">def</span> <span class="token function">co_present</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        res <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token keyword">lambda</span><span class="token punctuation">:</span> defaultdict<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> name_set <span class="token keyword">in</span> self<span class="token punctuation">.</span>names_by_sentence<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> name1<span class="token punctuation">,</span> name2 <span class="token keyword">in</span> combinations<span class="token punctuation">(</span>name_set<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                res<span class="token punctuation">[</span>name1<span class="token punctuation">]</span><span class="token punctuation">[</span>name2<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
                res<span class="token punctuation">[</span>name2<span class="token punctuation">]</span><span class="token punctuation">[</span>name1<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> res

</code></pre></div><h2 id="遗憾"><a href="#遗憾" class="header-anchor">#</a> 遗憾</h2> <ul><li>~~目前，还需要先选中角色，点击【选中角色】，才能选中该角色，编辑和查看其对应的别名。实际上这一步是赘余的、误导性的、破坏用户体验的。可以使用事件侦听处理掉。~~目前已使用事件侦听处理。</li> <li>没有使用面向对象的方式处理GUI。这是最大的痛点，后期维护上比较困难。</li> <li>使用Tk！Tk确实还是有很大的制约性的，各种控件的回调比较不自由，虽然可以通过事件侦听解决，但是可能会使得一些上下文相关的代码四散在各处（包括新建UI对象、UI的config、UI的variable设置、UI渲染都有各自的函数），在阅读代码时可能会有困难。</li></ul></div> <!----> <hr> <!----></div> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#实现的功能" title="实现的功能">实现的功能</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#用tk写gui真的反人类" title="用Tk写GUI真的反人类">用Tk写GUI真的反人类</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#关于分词词典和名称处理" title="关于分词词典和名称处理">关于分词词典和名称处理</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#关于共现矩阵" title="关于共现矩阵">关于共现矩阵</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#遗憾" title="遗憾">遗憾</a></div></div></div></div> <footer class="footer" data-v-582f9766><div class="footer-left-wrap" data-v-582f9766><ul class="contact" data-v-582f9766><li class="contact-item" data-v-582f9766><a href="https://github.com/KXXH" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-582f9766><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-582f9766><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-582f9766></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-582f9766><ul class="copyright" data-v-582f9766><li class="copyright-item" data-v-582f9766><a href="https://policies.google.com/privacy?hl=en-US" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-582f9766>Privacy Policy</a></li><li class="copyright-item" data-v-582f9766><a href="/2020/03/30/%E4%BD%BF%E7%94%A8tkinter%E5%BC%80%E5%8F%91%E5%9F%BA%E4%BA%8Ejieba%E7%9A%84%E5%89%A7%E6%83%85%E5%88%86%E8%AF%8D%E5%B7%A5%E5%85%B7/.html" class="nav-link" data-v-582f9766>MIT Licensed | Copyright © 2018-present Vue.js</a></li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5d19b8fa.js" defer></script><script src="/assets/js/9.785256bf.js" defer></script><script src="/assets/js/7.5b24e917.js" defer></script><script src="/assets/js/15.fa42f190.js" defer></script>
  </body>
</html>
